<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Final Assignment: Research Track I - Final Assignment S4482512 Enrico Fiasche&#39;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Final Assignment
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Research Track I - Final Assignment S4482512 Enrico Fiasche' </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>General information</h2>
<p>The assignment requires developing a software architecture for the control of the robot in the environment. The software will rely on the move_base and gmapping packages for localizing the robot and plan the motion.</p>
<p>The simulation can be launched by the executing the command:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;roslaunch final_assignment final.launch</div></div><!-- fragment --><h3>The simulation can perform the following behaviours:</h3>
<ul>
<li>1. Move the robot randomly in the environment, by choosing one out of six possible target positions;</li>
<li>2. Ask the user for the next target position (checking that the position is one of the possible six) and reach it;</li>
<li>3. Start following the external walls;</li>
<li>4. Stop the robot in the last position;</li>
<li>5. Change the planning algorithm to Dijkstra to bug0 and vice versa.</li>
</ul>
<p>If the robot is in state 1, or 2, the system should wait until the robot reaches the position in order to swtich to the state 3, 4 or 5.</p>
<h2>Nodes and Programs descriptions</h2>
<p>I have diffent programs used to achive the behaviours written above. The programs are written in Python and they are:</p><ul>
<li>The first one, <b><a class="el" href="go__to__point__service__m_8py.html">go_to_point_service_m.py</a></b>, is a service server used to go straight to the objective. This service is used when the robot has correct heading but it is away from the desired point. This service is used by the <b>bug0 algorithm</b> to reach the target point.</li>
<li>The second one, <b><a class="el" href="wall__follow__service__m_8py.html">wall_follow_service_m.py</a></b>, is a service server used to follow the wall. This service first of move the robot in a anti-clockwise circle until the wall is found. Then it reachs the wall and with the front-right obstructed the robot will follow the wall. This service is used to achive the point 3 (follow the wall) and is used on the <em>bug0 algorithm</em> to help to reach the target.</li>
<li>The third one, <b><a class="el" href="bug__m_8py.html">bug_m.py</a></b>, is a service server used to reach a given target point using the <b>bug0 algorithm</b>. This program starts as disabled with state "target reached" and with the service <b>go to point service</b> disabled. When it is activated, by the <b>control</b> program, the program waits a new target in the parameter <em>des_pos_x</em> and <em>des_pos_y</em>. When a new target is given the program starts a timer of 40 seconds, because not all target can be reached using this algorithm. It works using a simple state machine with three state:<ul>
<li>Go to point: denotes the state when the robot has correct heading but is away from the target point by a distance greater than some threshold (it is permormed by the service <b>go_to_point</b>)</li>
<li>Wall follower: denotes the state when robot heading differs from the desired heading by more than a threshold (it is performed by the service <b>wall_follow</b>)</li>
<li>Target reached: denotes the state when the robot has correct heading and has reached the destination. In this state the velocity is set to zero and it communicates to the <b>control</b> program that the goal is reached.</li>
</ul>
</li>
<li>The fourth program, <b><a class="el" href="user_command__server_8py.html">userCommand_server.py</a></b>, is a service server that, when it is active, allows the user to choose a command among five possible explained above. This service checks also if the new command is equal to the previous one, in order to avoid that the function is vainly repeated several time. If the new command is valid, it is saved inside a parameter <em>command</em> in order to be read in the <b>control</b> program.</li>
<li>The fifth program, <b><a class="el" href="user_target__server_8py.html">userTarget_server.py</a></b>, is a service server that allows the user to choose a new target between the six printed on the screen, this service is called when the user wants to execute the first command, so when the command is equal to one. The new target coordinates are saved inside two parameters, <em>des_pos_x</em> and <em>des_pos_y</em>, in order to be read in the <b>control</b> program.</li>
<li>The sixth program, <b><a class="el" href="random_target__server_8py.html">randomTarget_server.py</a></b>, is a service server that generates a random target among six possible goals, this service is called when the user wants to execute the second command, so when the command is equal to two. The new target coordinates are saved inside two parameters, <em>des_pos_x</em> and <em>des_pos_y</em>, in order to be read in the <b>control</b> program.</li>
<li>The last program, <b><a class="el" href="controller_8py.html">controller.py</a></b>, manages the behaviours of the robot. This program uses all the previous node services in order to perform correctly all the behaviours written above. It subscribes also to the topic <em>move_base/result</em> to understand when the robot change its status, from <em>ACTIVE</em> to <em>SUCCEEDED</em> (target reached). It also has two publisher used to pubish the goal for <b>move_base</b> and to publish the velocity through <b>cmd_vel</b>. This program has an endless loop, where it reads each time the value of the <b>command</b> inside a parameter. Based on the behaviours permormed by the robot explained before, the <b>controller</b> activates and disables the correct service taking in account if the bug0 is activated. If the bug0 isn't activated the new target is set calling the services interested and using the topic <em>move_base/goal</em> in order to allow the <b>move_base algorithm</b> to achive the objective, else if bug0 is activeted the program calling only the services interested, because inside this algorithm there is a part where it get the coordinates from the parameters.</li>
</ul>
<h2>Content packages</h2>
<p>The folder <em>final_assignment</em> contains launch files that allow the terminal to execute all nodes toghether, scripts files where are written the codes and the description of the world and the robot. <br />
&#160;&#160;&#160;&#160;.<br />
 &#160;&#160;&#160;&#160;|_ CMakeLists.txt<br />
 &#160;&#160;&#160;&#160;|_config<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ sim.riviz<br />
 &#160;&#160;&#160;&#160;|_ launch<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ final.launch<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ move_base.launch<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ simulation_gmapping.launch<br />
 &#160;&#160;&#160;&#160;|_ package.xml<br />
 &#160;&#160;&#160;&#160;|_ param<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ base_local_planner_params.yaml<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ costmap_common_params.yaml<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ global_costmap_params.yaml<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ local_costmap_params.yaml<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ move_base_params.yaml<br />
 &#160;&#160;&#160;&#160;|_ rosgraph.svg<br />
 &#160;&#160;&#160;&#160;|_ scripts<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ <a class="el" href="bug__m_8py.html">bug_m.py</a><br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ <a class="el" href="controller_8py.html">controller.py</a><br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ <a class="el" href="go__to__point__service__m_8py.html">go_to_point_service_m.py</a><br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ <a class="el" href="random_target__server_8py.html">randomTarget_server.py</a><br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ <a class="el" href="user_command__server_8py.html">userCommand_server.py</a><br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ <a class="el" href="user_target__server_8py.html">userTarget_server.py</a><br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ <a class="el" href="wall__follow__service__m_8py.html">wall_follow_service_m.py</a><br />
 &#160;&#160;&#160;&#160;|_ tree.png<br />
 &#160;&#160;&#160;&#160;|_ urdf<br />
 &#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;|_ robot.urdf<br />
 &#160;&#160;&#160;&#160;|_ worlds<br />
<br />
 Inside the final.launch there are all the nodes useful to start the simulation and to perform the given behaviours. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
